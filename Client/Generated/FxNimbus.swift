// This file was autogenerated by the `nimbus-fml` crate.
// Trust me, you don't want to mess with it!
#if canImport(MozillaAppServices)
    import MozillaAppServices
#endif

///
/// An object for safely accessing feature configuration from Nimbus.
///
/// This is generated.
public class FxNimbus : FeatureManifestInterface {
    public typealias Features = FxNimbusFeatures

    ///
    /// This should be populated at app launch; this method of initializing features
    /// will be removed in favor of the `initialize` function.
    ///
    public var api: FeaturesInterface?

    ///
    /// This method should be called as early in the startup sequence of the app as possible.
    /// This is to connect the Nimbus SDK (and thus server) with the `FxNimbus`
    /// class.
    ///
    /// The lambda MUST be threadsafe in its own right.
    public func initialize(with getSdk: @escaping () -> FeaturesInterface?) {
        self.getSdk = getSdk
        self.features.shareSheet.with(sdk: getSdk)
        self.features.homescreenFeature.with(sdk: getSdk)
        self.features.generalAppFeatures.with(sdk: getSdk)
        self.features.spotlightSearch.with(sdk: getSdk)
        self.features.tabTrayFeature.with(sdk: getSdk)
        self.features.searchTermGroupsFeature.with(sdk: getSdk)
        self.features.messaging.with(sdk: getSdk)
        self.features.wallpaperFeature.with(sdk: getSdk)
        self.features.search.with(sdk: getSdk)
        self.features.contextualHintFeature.with(sdk: getSdk)
        self.features.onboardingFeature.with(sdk: getSdk)
        self.features.startAtHomeFeature.with(sdk: getSdk)
        self.features.creditCardAutofill.with(sdk: getSdk)
        self.reinitialize()
    }

    fileprivate lazy var getSdk: GetSdk = { [self] in self.api }

    ///
    /// Represents all the features supported by Nimbus
    ///
    public let features = Features()

    ///
    /// All generated initialization code. Clients shouldn't need to override or call
    /// this.
    /// We put it in a separate method because we have to be quite careful about what order
    /// the initialization happens inâ€” e.g. when importing other FML files.
    ///
    private func reinitialize() {
        // Nothing left to do.
    }

    ///
    /// Refresh the cache of configuration objects.
    ///
    /// For performance reasons, the feature configurations are constructed once then cached.
    /// This method is to clear that cache for all features configured with Nimbus.
    ///
    /// It must be called whenever the Nimbus SDK finishes the `applyPendingExperiments()` method.
    ///
    public func invalidateCachedValues() {
        features.shareSheet.with(cachedValue: nil)
        features.homescreenFeature.with(cachedValue: nil)
        features.generalAppFeatures.with(cachedValue: nil)
        features.spotlightSearch.with(cachedValue: nil)
        features.tabTrayFeature.with(cachedValue: nil)
        features.searchTermGroupsFeature.with(cachedValue: nil)
        features.messaging.with(cachedValue: nil)
        features.wallpaperFeature.with(cachedValue: nil)
        features.search.with(cachedValue: nil)
        features.contextualHintFeature.with(cachedValue: nil)
        features.onboardingFeature.with(cachedValue: nil)
        features.startAtHomeFeature.with(cachedValue: nil)
        features.creditCardAutofill.with(cachedValue: nil)
    }

    ///
    /// A singleton instance of FxNimbus
    ///
    public static let shared = FxNimbus()
}

public class FxNimbusFeatures {
    /// This feature define the redesign of the share sheet
    public lazy var shareSheet: FeatureHolder<ShareSheet> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "share-sheet") { (variables) in
            ShareSheet(variables)
        }
    }()
    /// The homescreen that the user goes to when they press home or new tab.
    public lazy var homescreenFeature: FeatureHolder<HomescreenFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "homescreenFeature") { (variables) in
            HomescreenFeature(variables)
        }
    }()
    /// The feature that contains feature flags for the entire application
    public lazy var generalAppFeatures: FeatureHolder<GeneralAppFeatures> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "general-app-features") { (variables) in
            GeneralAppFeatures(variables)
        }
    }()
    /// Add pages as items findable with Spotlight.
    public lazy var spotlightSearch: FeatureHolder<SpotlightSearch> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "spotlight-search") { (variables) in
            SpotlightSearch(variables)
        }
    }()
    /// The tab tray screen that the user goes to when they open the tab tray.
    public lazy var tabTrayFeature: FeatureHolder<TabTrayFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tabTrayFeature") { (variables) in
            TabTrayFeature(variables)
        }
    }()
    /// The feature that controls whether or not search term groups are enabled.
    public lazy var searchTermGroupsFeature: FeatureHolder<SearchTermGroupsFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "search-term-groups-feature") { (variables) in
            SearchTermGroupsFeature(variables)
        }
    }()
    /// Configuration for the messaging system.
         /// In practice this is a set of growable lookup tables for the message
         /// controller to piece together.
         /// 
    public lazy var messaging: FeatureHolder<Messaging> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "messaging") { (variables) in
            Messaging(variables)
        }
    }()
    /// This property defines the configuration for the wallpaper feature
    public lazy var wallpaperFeature: FeatureHolder<WallpaperFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "wallpaper-feature") { (variables) in
            WallpaperFeature(variables)
        }
    }()
    /// Configuring the functionality to do with search. This will be separated into
         /// smaller sub-features in later releases.
         /// 
    public lazy var search: FeatureHolder<Search> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "search") { (variables) in
            Search(variables)
        }
    }()
    /// This set holds all features pertaining to contextual hints.
    public lazy var contextualHintFeature: FeatureHolder<ContextualHintFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "contextual-hint-feature") { (variables) in
            ContextualHintFeature(variables)
        }
    }()
    /// The feature that controls whether to show or not Upgrade onboarding
    public lazy var onboardingFeature: FeatureHolder<OnboardingFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "onboarding-feature") { (variables) in
            OnboardingFeature(variables)
        }
    }()
    /// The controls for Start at Home feature
    public lazy var startAtHomeFeature: FeatureHolder<StartAtHomeFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "start-at-home-feature") { (variables) in
            StartAtHomeFeature(variables)
        }
    }()
    /// This property defines the credit card autofill feature
    public lazy var creditCardAutofill: FeatureHolder<CreditCardAutofill> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "credit-card-autofill") { (variables) in
            CreditCardAutofill(variables)
        }
    }()
}

// Public interface members begin here.


/// This feature define the redesign of the share sheet
public class ShareSheet {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let moveActions: Bool
        let toolbarChanges: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        moveActions: Bool = true,
        toolbarChanges: Bool = true
    ) {
        self.init(variables: _variables, defaults: Defaults(
            moveActions: moveActions,
            toolbarChanges: toolbarChanges))
    }

    /// If true copy and send to device are moved to share sheet
    public lazy var moveActions: Bool = {
        self._variables.getBool("move-actions") ?? _defaults.moveActions
    }()
    /// If true share option is shown on the toolbar
    public lazy var toolbarChanges: Bool = {
        self._variables.getBool("toolbar-changes") ?? _defaults.toolbarChanges
    }()
}



/// The homescreen that the user goes to when they press home or new tab.
public class HomescreenFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let jumpBackInSyncedTab: Bool
        let pocketSponsoredStories: Bool
        let sectionsEnabled: [HomeScreenSection: Bool]
        let sponsoredTiles: SponsoredTiles
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        jumpBackInSyncedTab: Bool = true,
        pocketSponsoredStories: Bool = true,
        sectionsEnabled: [HomeScreenSection: Bool] = [.jumpBackIn: true, .pocket: true, .recentExplorations: true, .recentlySaved: true, .topSites: true],
        sponsoredTiles: SponsoredTiles = SponsoredTiles(maxNumberOfTiles: 2, status: true)
    ) {
        self.init(variables: _variables, defaults: Defaults(
            jumpBackInSyncedTab: jumpBackInSyncedTab,
            pocketSponsoredStories: pocketSponsoredStories,
            sectionsEnabled: sectionsEnabled,
            sponsoredTiles: sponsoredTiles))
    }

    /// This property defines whether the synced tab card appears on the homepage in
     /// the jump back in section.
     /// 
    public lazy var jumpBackInSyncedTab: Bool = {
        self._variables.getBool("jump-back-in-synced-tab") ?? _defaults.jumpBackInSyncedTab
    }()
    /// This property defines whether pocket sponsored stories appear on the
     /// homepage.
     /// 
    public lazy var pocketSponsoredStories: Bool = {
        self._variables.getBool("pocket-sponsored-stories") ?? _defaults.pocketSponsoredStories
    }()
    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
     /// 
    public lazy var sectionsEnabled: [HomeScreenSection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(HomeScreenSection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
    /// This property defines the sponsored tile feature on the homepage, which is
     /// not a section therein.
     /// 
    public lazy var sponsoredTiles: SponsoredTiles = {
        self._variables.getVariables("sponsored-tiles")?.map(SponsoredTiles.create)._mergeWith(_defaults.sponsoredTiles) ?? _defaults.sponsoredTiles
    }()
}



/// The feature that contains feature flags for the entire application
public class GeneralAppFeatures {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let pullToRefresh: GeneralFeature
        let reportSiteIssue: GeneralFeature
        let shakeToRestore: GeneralFeature
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        pullToRefresh: GeneralFeature = GeneralFeature(status: true),
        reportSiteIssue: GeneralFeature = GeneralFeature(status: true),
        shakeToRestore: GeneralFeature = GeneralFeature(status: true)
    ) {
        self.init(variables: _variables, defaults: Defaults(
            pullToRefresh: pullToRefresh,
            reportSiteIssue: reportSiteIssue,
            shakeToRestore: shakeToRestore))
    }

    /// This property defines whether or not the feature is enabled
    public lazy var pullToRefresh: GeneralFeature = {
        self._variables.getVariables("pull-to-refresh")?.map(GeneralFeature.create)._mergeWith(_defaults.pullToRefresh) ?? _defaults.pullToRefresh
    }()
    /// This property defines whether or not the feature is enabled
    public lazy var reportSiteIssue: GeneralFeature = {
        self._variables.getVariables("report-site-issue")?.map(GeneralFeature.create)._mergeWith(_defaults.reportSiteIssue) ?? _defaults.reportSiteIssue
    }()
    /// This property defines whether or not the feature is enabled
    public lazy var shakeToRestore: GeneralFeature = {
        self._variables.getVariables("shake-to-restore")?.map(GeneralFeature.create)._mergeWith(_defaults.shakeToRestore) ?? _defaults.shakeToRestore
    }()
}



/// Add pages as items findable with Spotlight.
public class SpotlightSearch {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let enabled: Bool
        let iconType: IconType?
        let keepForDays: Int?
        let searchableContent: PageContent?
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        enabled: Bool = true,
        iconType: IconType? = .screenshot,
        keepForDays: Int? = nil,
        searchableContent: PageContent? = .textExcerpt
    ) {
        self.init(variables: _variables, defaults: Defaults(
            enabled: enabled,
            iconType: iconType,
            keepForDays: keepForDays,
            searchableContent: searchableContent))
    }

    /// If this is true, then on each page load adds a new item to Spotlight.
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    /// The icon that is displayed next to the item in the search results. If this
     /// is `null`, then no icon is displayed.
     /// 
    public lazy var iconType: IconType? = {
        self._variables.getString("icon-type")?.map(IconType.enumValue) ?? _defaults.iconType
    }()
    /// Number of days to keep the item before automatic deletion. If this is left
     /// `null`, then it is left to iOS's default.
     /// 
    public lazy var keepForDays: Int? = {
        self._variables.getInt("keep-for-days") ?? _defaults.keepForDays
    }()
    /// The text content that is made searchable. If this is `null` then no
     /// additional content is used, and only the title and URL will be used.
     /// 
    public lazy var searchableContent: PageContent? = {
        self._variables.getString("searchable-content")?.map(PageContent.enumValue) ?? _defaults.searchableContent
    }()
}



/// The tab tray screen that the user goes to when they open the tab tray.
public class TabTrayFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let sectionsEnabled: [TabTraySection: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        sectionsEnabled: [TabTraySection: Bool] = [.inactiveTabs: true]
    ) {
        self.init(variables: _variables, defaults: Defaults(
            sectionsEnabled: sectionsEnabled))
    }

    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
    public lazy var sectionsEnabled: [TabTraySection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(TabTraySection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
}



/// The feature that controls whether or not search term groups are enabled.
public class SearchTermGroupsFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let groupingEnabled: [SearchTermGroups: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        groupingEnabled: [SearchTermGroups: Bool] = [.historyGroups: true, .tabTrayGroups: true]
    ) {
        self.init(variables: _variables, defaults: Defaults(
            groupingEnabled: groupingEnabled))
    }

    /// This property provides a lookup table of whether or not the given grouping
     /// should be enabled.
    public lazy var groupingEnabled: [SearchTermGroups: Bool] = {
        self._variables.getBoolMap("grouping-enabled")?.mapKeysNotNull(SearchTermGroups.enumValue).mergeWith(_defaults.groupingEnabled) ?? _defaults.groupingEnabled
    }()
}



/// Configuration for the messaging system.
 /// In practice this is a set of growable lookup tables for the message
 /// controller to piece together.
 /// 
public class Messaging {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let actions: [String: String]
        let messageUnderExperiment: String?
        let messages: [String: MessageData]
        let onControl: ControlMessageBehavior
        let styles: [String: StyleData]
        let triggers: [String: String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        actions: [String: String] = ["ENABLE_PRIVATE_BROWSING": "://deep-link?url=homepanel/new-private-tab", "MAKE_DEFAULT_BROWSER": "://deep-link?url=default-browser/system-settings", "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL": "://deep-link?url=default-browser/tutorial", "OPEN_SETTINGS": "://deep-link?url=settings/general", "OPEN_SETTINGS_EMAIL": "://deep-link?url=settings/mailto", "OPEN_SETTINGS_FXA": "://deep-link?url=settings/fxa", "OPEN_SETTINGS_HOMESCREEN": "://deep-link?url=settings/homepage", "OPEN_SETTINGS_NEW_TAB": "://deep-link?url=settings/newtab", "OPEN_SETTINGS_PRIVACY": "://deep-link?url=settings/clear-private-data", "OPEN_SETTINGS_SEARCH_ENGINE": "://deep-link?url=settings/search", "OPEN_SETTINGS_THEME": "://deep-link?url=settings/theme", "OPEN_SETTINGS_WALLPAPERS": "://deep-link?url=settings/wallpaper", "VIEW_BOOKMARKS": "://deep-link?url=homepanel/bookmarks", "VIEW_DOWNLOADS": "://deep-link?url=homepanel/downloads", "VIEW_HISTORY": "://deep-link?url=homepanel/history", "VIEW_READING_LIST": "://deep-link?url=homepanel/reading-list", "VIEW_TOP_SITES": "://deep-link?url=homepanel/top-sites"],
        messageUnderExperiment: String? = nil,
        messages: [String: MessageData] = ["default-browser": MessageData(action: "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL", buttonLabel: "Default Browser/DefaultBrowserCard.Button.v2", style: "FALLBACK", surface: .newTabCard, text: "Default Browser/DefaultBrowserCard.Description", title: "Default Browser/DefaultBrowserCard.Title", trigger: ["I_AM_NOT_DEFAULT_BROWSER", "SUPPORTS_DEFAULT_BROWSER"]), "research-survey": MessageData(action: "www.macrumors.com", buttonLabel: "Research Surface/PrimaryButton.Label", style: "SURVEY", surface: .survey, text: "Research Surface/Body.Text", trigger: ["ALWAYS"])],
        onControl: ControlMessageBehavior = .showNextMessage,
        styles: [String: StyleData] = ["DEFAULT": StyleData(maxDisplayCount: 5, priority: 50), "FALLBACK": StyleData(maxDisplayCount: 20, priority: 40), "PERSISTENT": StyleData(maxDisplayCount: 20, priority: 50), "SURVEY": StyleData(maxDisplayCount: 10, priority: 55), "URGENT": StyleData(maxDisplayCount: 10, priority: 100), "WARNING": StyleData(maxDisplayCount: 10, priority: 60)],
        triggers: [String: String] = ["AFTER_THREE_LAUNCHES_THIS_WEEK": "app_cycle.foreground|eventSum('Weeks', 1, 0) >= 3", "ALWAYS": "true", "DEVICE_ANDROID": "os == 'Android'", "DEVICE_IOS": "os == 'iOS'", "I_AM_DEFAULT_BROWSER": "is_default_browser", "I_AM_NOT_DEFAULT_BROWSER": "is_default_browser == false", "NEVER": "false", "NOT_INSTALLED_TODAY": "days_since_install > 0", "NOT_LAUNCHED_YESTERDAY": "app_cycle.foreground|eventLastSeen('Days', 1) > 1", "SUPPORTS_DEFAULT_BROWSER": "os_version|versionCompare('14.!') >= 0", "USER_DE_SPEAKER": "'de' in locale", "USER_EN_SPEAKER": "'en' in locale", "USER_FR_SPEAKER": "'fr' in locale", "USER_RECENTLY_INSTALLED": "days_since_install < 7", "USER_RECENTLY_UPDATED": "days_since_update < 7 && days_since_install != days_since_update", "USER_TIER_ONE_COUNTRY": "('US' in locale || 'GB' in locale || 'CA' in locale || 'DE' in locale || 'FR' in locale)"]
    ) {
        self.init(variables: _variables, defaults: Defaults(
            actions: actions,
            messageUnderExperiment: messageUnderExperiment,
            messages: messages,
            onControl: onControl,
            styles: styles,
            triggers: triggers))
    }

    /// A growable map of action URLs.
    public lazy var actions: [String: String] = {
        self._variables.getStringMap("actions")?.mergeWith(_defaults.actions) ?? _defaults.actions
    }()
    /// Id or prefix of the message under experiment.
    public lazy var messageUnderExperiment: String? = {
        self._variables.getString("message-under-experiment") ?? _defaults.messageUnderExperiment
    }()
    /// A growable collection of messages, where the Key is the message identifier
     /// and the value is its associated MessageData.
     /// 
    public lazy var messages: [String: MessageData] = {
        self._variables.getVariablesMap("messages")?.mapValuesNotNull(MessageData.create).mergeWith(_defaults.messages, MessageData.mergeWith) ?? _defaults.messages
    }()
    /// What should be displayed when a control message is selected.
    public lazy var onControl: ControlMessageBehavior = {
        self._variables.getString("on-control")?.map(ControlMessageBehavior.enumValue) ?? _defaults.onControl
    }()
    /// A map of styles to configure message appearance.
     /// 
    public lazy var styles: [String: StyleData] = {
        self._variables.getVariablesMap("styles")?.mapValuesNotNull(StyleData.create).mergeWith(_defaults.styles, StyleData.mergeWith) ?? _defaults.styles
    }()
    /// A collection of out the box trigger expressions. Each entry maps to a valid
     /// JEXL expression.
     /// 
    public lazy var triggers: [String: String] = {
        self._variables.getStringMap("triggers")?.mergeWith(_defaults.triggers) ?? _defaults.triggers
    }()
}



/// This property defines the configuration for the wallpaper feature
public class WallpaperFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let configuration: WallpaperConfiguration
        let onboardingSheet: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        configuration: WallpaperConfiguration = WallpaperConfiguration(status: true, version: .v1),
        onboardingSheet: Bool = true
    ) {
        self.init(variables: _variables, defaults: Defaults(
            configuration: configuration,
            onboardingSheet: onboardingSheet))
    }

    /// This property defines the configuration for the wallpaper feature
    public lazy var configuration: WallpaperConfiguration = {
        self._variables.getVariables("configuration")?.map(WallpaperConfiguration.create)._mergeWith(_defaults.configuration) ?? _defaults.configuration
    }()
    /// This property defines whether the wallpaper onboarding is shown or not
    public lazy var onboardingSheet: Bool = {
        self._variables.getBool("onboarding-sheet") ?? _defaults.onboardingSheet
    }()
}



/// Configuring the functionality to do with search. This will be separated into
 /// smaller sub-features in later releases.
 /// 
public class Search {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let awesomeBar: AwesomeBar
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        awesomeBar: AwesomeBar = AwesomeBar(position: SearchBarPositionFeature(isBottom: false, isPositionFeatureEnabled: true, isToolbarCfrOn: true), searchHighlights: false, usePageContent: false)
    ) {
        self.init(variables: _variables, defaults: Defaults(
            awesomeBar: awesomeBar))
    }

    /// Configuring the awesome bar.
    public lazy var awesomeBar: AwesomeBar = {
        self._variables.getVariables("awesome-bar")?.map(AwesomeBar.create)._mergeWith(_defaults.awesomeBar) ?? _defaults.awesomeBar
    }()
}



/// This set holds all features pertaining to contextual hints.
public class ContextualHintFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let featuresEnabled: [ContextualHint: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        featuresEnabled: [ContextualHint: Bool] = [.jumpBackInSyncedTabContextualHint: false, .toolbarHint: false]
    ) {
        self.init(variables: _variables, defaults: Defaults(
            featuresEnabled: featuresEnabled))
    }

    /// This property provides a lookup table of whether specific contextual hints
     /// are enabled.
     /// 
    public lazy var featuresEnabled: [ContextualHint: Bool] = {
        self._variables.getBoolMap("features-enabled")?.mapKeysNotNull(ContextualHint.enumValue).mergeWith(_defaults.featuresEnabled) ?? _defaults.featuresEnabled
    }()
}



/// The feature that controls whether to show or not Upgrade onboarding
public class OnboardingFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let firstRunFlow: Bool
        let upgradeFlow: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        firstRunFlow: Bool = true,
        upgradeFlow: Bool = false
    ) {
        self.init(variables: _variables, defaults: Defaults(
            firstRunFlow: firstRunFlow,
            upgradeFlow: upgradeFlow))
    }

    /// If true, we show the new Onboarding screen when the user for v106 version.
     /// 
    public lazy var firstRunFlow: Bool = {
        self._variables.getBool("first-run-flow") ?? _defaults.firstRunFlow
    }()
    /// If true, we show the Upgrade onboarding screen when the user upgrades the
     /// version.
     /// 
    public lazy var upgradeFlow: Bool = {
        self._variables.getBool("upgrade-flow") ?? _defaults.upgradeFlow
    }()
}



/// The controls for Start at Home feature
public class StartAtHomeFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let setting: StartAtHome
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        setting: StartAtHome = .afterFourHours
    ) {
        self.init(variables: _variables, defaults: Defaults(
            setting: setting))
    }

    /// This property provides a default setting for the startAtHomeFeature
    public lazy var setting: StartAtHome = {
        self._variables.getString("setting")?.map(StartAtHome.enumValue) ?? _defaults.setting
    }()
}



/// This property defines the credit card autofill feature
public class CreditCardAutofill {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let creditCardAutofillStatus: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        creditCardAutofillStatus: Bool = true
    ) {
        self.init(variables: _variables, defaults: Defaults(
            creditCardAutofillStatus: creditCardAutofillStatus))
    }

    /// If true, we will allow user to use the credit autofill feature
    public lazy var creditCardAutofillStatus: Bool = {
        self._variables.getBool("credit-card-autofill-status") ?? _defaults.creditCardAutofillStatus
    }()
}




/// The identifiers for the different types of search term groups.
public enum SearchTermGroups: String, CaseIterable {
    
    /// Grouping for items in History and RecentlyVisited
    case historyGroups = "history-groups"
    
    /// Grouping for items in the Tab Tray and in JumpBackIn
    case tabTrayGroups = "tab-tray-groups"
    

    public static func enumValue(_ s: String?) -> SearchTermGroups? {
        guard let s = s else {
            return nil
        }
        return SearchTermGroups(rawValue: s)
    }
}


/// The identifiers for the sections of the homescreen.
public enum HomeScreenSection: String, CaseIterable {
    
    /// The frecency and pinned sites.
    case topSites = "top-sites"
    
    /// The tabs the user was looking immediately before being interrupted.
    case jumpBackIn = "jump-back-in"
    
    /// The pocket section. This should only be available in the US.
    case pocket = "pocket"
    
    /// The tab groups
    case recentExplorations = "recent-explorations"
    
    /// The sites the user has bookmarked recently.
    case recentlySaved = "recently-saved"
    

    public static func enumValue(_ s: String?) -> HomeScreenSection? {
        guard let s = s else {
            return nil
        }
        return HomeScreenSection(rawValue: s)
    }
}


/// The identifiers for the different types of options for StartAtHome
public enum StartAtHome: String, CaseIterable {
    
    /// App opens to a new homepage tab after four hours of inactivity
    case afterFourHours = "after-four-hours"
    
    /// App opens to a new homepage tab after five minutes of inactiviny
    case always = "always"
    
    /// App always opens to the last tab the user was on.
    case disabled = "disabled"
    

    public static func enumValue(_ s: String?) -> StartAtHome? {
        guard let s = s else {
            return nil
        }
        return StartAtHome(rawValue: s)
    }
}


/// The identifiers for a individual contextual hints.
public enum ContextualHint: String, CaseIterable {
    
    /// The contextual hint bubble that appears to indicate a synced tab has
     /// appeared within the Jump Back In section.
    case jumpBackInSyncedTabContextualHint = "jump-back-in-synced-tab-contextual-hint"
    
    /// The contextual hint bubble that appears to provide a hint about the toolbar.
    case toolbarHint = "toolbar-hint"
    

    public static func enumValue(_ s: String?) -> ContextualHint? {
        guard let s = s else {
            return nil
        }
        return ContextualHint(rawValue: s)
    }
}


/// An enum to identify which version of the wallpaper system to use
public enum WallpaperVariantVersion: String, CaseIterable {
    
    /// The 2022 MR version
    case v1 = "v1"
    
    /// The legacy wallpaper version
    case legacy = "legacy"
    

    public static func enumValue(_ s: String?) -> WallpaperVariantVersion? {
        guard let s = s else {
            return nil
        }
        return WallpaperVariantVersion(rawValue: s)
    }
}


/// The icon that will be added to the item in the device's search engine.
public enum IconType: String, CaseIterable {
    
    /// A screenshot of the page at load time.
    case screenshot = "screenshot"
    
    /// The favicon of the page
    case favicon = "favicon"
    
    /// An icon generated from the first letter of the base domain.
    case letter = "letter"
    

    public static func enumValue(_ s: String?) -> IconType? {
        guard let s = s else {
            return nil
        }
        return IconType(rawValue: s)
    }
}


/// The page content that will be added as an item in the device's search
 /// engine.
public enum PageContent: String, CaseIterable {
    
    /// Only use the first paragraph
    case textExcerpt = "text-excerpt"
    
    /// Use all the page as HTML
    case htmlContent = "html-content"
    
    /// Use all the page as text
    case textContent = "text-content"
    

    public static func enumValue(_ s: String?) -> PageContent? {
        guard let s = s else {
            return nil
        }
        return PageContent(rawValue: s)
    }
}


/// For messaging, we would like to have a message tell us which surface its
 /// associated with. This is a label that matches across both Android and iOS.
 /// 
public enum MessageSurfaceId: String, CaseIterable {
    
    /// This is a full-page that appears providing a survey to the user.
    case survey = "survey"
    
    /// This is the card that appears at the top on the Firefox Home Page.
    case newTabCard = "new-tab-card"
    
    /// A message has NOT declared its target surface.
    case unknown = "Unknown"
    

    public static func enumValue(_ s: String?) -> MessageSurfaceId? {
        guard let s = s else {
            return nil
        }
        return MessageSurfaceId(rawValue: s)
    }
}


/// An enum to influence what should be displayed when a control message is
 /// selected.
public enum ControlMessageBehavior: String, CaseIterable {
    
    /// The next eligible message should be shown.
    case showNextMessage = "show-next-message"
    
    /// The surface should show no message.
    case showNone = "show-none"
    

    public static func enumValue(_ s: String?) -> ControlMessageBehavior? {
        guard let s = s else {
            return nil
        }
        return ControlMessageBehavior(rawValue: s)
    }
}


/// The identifiers for the sections of the tab tray.
public enum TabTraySection: String, CaseIterable {
    
    /// Tabs that have been automatically closed for the user.
    case inactiveTabs = "inactive-tabs"
    

    public static func enumValue(_ s: String?) -> TabTraySection? {
        guard let s = s else {
            return nil
        }
        return TabTraySection(rawValue: s)
    }
}

/// The configuration for the a feature that can be enabled or disabled
public class WallpaperConfiguration {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let status: Bool
        let version: WallpaperVariantVersion
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        status: Bool = false,
        version: WallpaperVariantVersion = .legacy
    ) {
        self.init(variables: _variables, defaults: Defaults(
            status: status,
            version: version))
    }

    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    /// Which version of the wallpaper sytem to use
    public lazy var version: WallpaperVariantVersion = {
        self._variables.getString("version")?.map(WallpaperVariantVersion.enumValue) ?? _defaults.version
    }()
}

public extension WallpaperConfiguration {
    func _mergeWith(_ defaults: WallpaperConfiguration?) -> WallpaperConfiguration {
        guard let defaults = defaults else {
            return self
        }
        return WallpaperConfiguration(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> WallpaperConfiguration {
        return WallpaperConfiguration(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: WallpaperConfiguration, _ defaults: WallpaperConfiguration) -> WallpaperConfiguration {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the a feature that can be enabled or disabled
public class GeneralFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        status: Bool = false
    ) {
        self.init(variables: _variables, defaults: Defaults(
            status: status))
    }

    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
}

public extension GeneralFeature {
    func _mergeWith(_ defaults: GeneralFeature?) -> GeneralFeature {
        guard let defaults = defaults else {
            return self
        }
        return GeneralFeature(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> GeneralFeature {
        return GeneralFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: GeneralFeature, _ defaults: GeneralFeature) -> GeneralFeature {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the bottom search bar on the homescreen
public class SearchBarPositionFeature {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let isBottom: Bool
        let isPositionFeatureEnabled: Bool
        let isToolbarCfrOn: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        isBottom: Bool = true,
        isPositionFeatureEnabled: Bool = true,
        isToolbarCfrOn: Bool = true
    ) {
        self.init(variables: _variables, defaults: Defaults(
            isBottom: isBottom,
            isPositionFeatureEnabled: isPositionFeatureEnabled,
            isToolbarCfrOn: isToolbarCfrOn))
    }

    /// Whether or not the default position is at the bottom
    public lazy var isBottom: Bool = {
        self._variables.getBool("is-bottom") ?? _defaults.isBottom
    }()
    /// Whether or not the feature is enabled
    public lazy var isPositionFeatureEnabled: Bool = {
        self._variables.getBool("is-position-feature-enabled") ?? _defaults.isPositionFeatureEnabled
    }()
    /// Whether or not the toolbar CFR shows. This is a temporary hack for Nimbus
    public lazy var isToolbarCfrOn: Bool = {
        self._variables.getBool("is-toolbar-cfr-on") ?? _defaults.isToolbarCfrOn
    }()
}

public extension SearchBarPositionFeature {
    func _mergeWith(_ defaults: SearchBarPositionFeature?) -> SearchBarPositionFeature {
        guard let defaults = defaults else {
            return self
        }
        return SearchBarPositionFeature(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> SearchBarPositionFeature {
        return SearchBarPositionFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: SearchBarPositionFeature, _ defaults: SearchBarPositionFeature) -> SearchBarPositionFeature {
        return overrides._mergeWith(defaults)
    }
}

/// An object to describe a message. It uses human readable strings to describe
 /// the triggers, action and style of the message as well as the text of the
 /// message and call to action.
 /// 
public class MessageData {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let action: String
        let buttonLabel: String?
        let isControl: Bool
        let style: String
        let surface: MessageSurfaceId
        let text: String
        let title: String?
        let trigger: [String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        action: String = "",
        buttonLabel: String? = nil,
        isControl: Bool = false,
        style: String = "DEFAULT",
        surface: MessageSurfaceId = .unknown,
        text: String = "",
        title: String? = nil,
        trigger: [String] = []
    ) {
        self.init(variables: _variables, defaults: Defaults(
            action: action,
            buttonLabel: buttonLabel,
            isControl: isControl,
            style: style,
            surface: surface,
            text: text,
            title: title,
            trigger: trigger))
    }

    /// A URL of a page or a deeplink. This may have substitution variables in.
     /// 
    public lazy var action: String = {
        self._variables.getString("action") ?? _defaults.action
    }()
    /// The text on the button. If no text is present, the whole message is
     /// clickable.
     /// 
    public lazy var buttonLabel: String? = {
        self._variables.getText("button-label") ?? _defaults.buttonLabel.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    /// Indicates if this message is the control message, if true shouldn't be
     /// displayed
    public lazy var isControl: Bool = {
        self._variables.getBool("is-control") ?? _defaults.isControl
    }()
    /// The style as described in a `StyleData` from the styles table.
     /// 
    public lazy var style: String = {
        self._variables.getString("style") ?? _defaults.style
    }()
    /// Each message will tell us the surface it is targeting with this.
    public lazy var surface: MessageSurfaceId = {
        self._variables.getString("surface")?.map(MessageSurfaceId.enumValue) ?? _defaults.surface
    }()
    /// The message text displayed to the user
    public lazy var text: String = {
        self._variables.getText("text") ?? self._variables.resourceBundles.getString(named: _defaults.text) ?? _defaults.text
    }()
    /// The title text displayed to the user
    public lazy var title: String? = {
        self._variables.getText("title") ?? _defaults.title.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    /// A list of strings corresponding to targeting expressions. The message will
     /// be shown if all expressions `true`.
     /// 
    public lazy var trigger: [String] = {
        self._variables.getStringList("trigger") ?? _defaults.trigger
    }()
}

public extension MessageData {
    func _mergeWith(_ defaults: MessageData?) -> MessageData {
        guard let defaults = defaults else {
            return self
        }
        return MessageData(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> MessageData {
        return MessageData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: MessageData, _ defaults: MessageData) -> MessageData {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properities (predominantly visual) to the describe style of the
 /// message.
 /// 
public class StyleData {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let maxDisplayCount: Int
        let priority: Int
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        maxDisplayCount: Int = 5,
        priority: Int = 50
    ) {
        self.init(variables: _variables, defaults: Defaults(
            maxDisplayCount: maxDisplayCount,
            priority: priority))
    }

    /// How many sessions will this message be shown to the user before it is
     /// expired.
     /// 
    public lazy var maxDisplayCount: Int = {
        self._variables.getInt("max-display-count") ?? _defaults.maxDisplayCount
    }()
    /// The importance of this message. 0 is not very important, 100 is very
     /// important.
     /// 
    public lazy var priority: Int = {
        self._variables.getInt("priority") ?? _defaults.priority
    }()
}

public extension StyleData {
    func _mergeWith(_ defaults: StyleData?) -> StyleData {
        guard let defaults = defaults else {
            return self
        }
        return StyleData(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> StyleData {
        return StyleData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: StyleData, _ defaults: StyleData) -> StyleData {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the sponsored tile on the homescreen
public class SponsoredTiles {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let maxNumberOfTiles: Int
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        maxNumberOfTiles: Int = 2,
        status: Bool = false
    ) {
        self.init(variables: _variables, defaults: Defaults(
            maxNumberOfTiles: maxNumberOfTiles,
            status: status))
    }

    /// The maximum number of sponsored tiles a user can see
    public lazy var maxNumberOfTiles: Int = {
        self._variables.getInt("max-number-of-tiles") ?? _defaults.maxNumberOfTiles
    }()
    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
}

public extension SponsoredTiles {
    func _mergeWith(_ defaults: SponsoredTiles?) -> SponsoredTiles {
        guard let defaults = defaults else {
            return self
        }
        return SponsoredTiles(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> SponsoredTiles {
        return SponsoredTiles(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: SponsoredTiles, _ defaults: SponsoredTiles) -> SponsoredTiles {
        return overrides._mergeWith(defaults)
    }
}

/// A configuration option for the awesome bar. Part of the `search` feature.
public class AwesomeBar {
    private let _variables: Variables
    private let _defaults: Defaults
    private init(variables: Variables = NilVariables.instance, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
    }
    
    struct Defaults {
        let minSearchTerm: Int
        let position: SearchBarPositionFeature
        let searchHighlights: Bool
        let usePageContent: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance, 
        minSearchTerm: Int = 3,
        position: SearchBarPositionFeature = SearchBarPositionFeature(isBottom: true, isPositionFeatureEnabled: true, isToolbarCfrOn: true),
        searchHighlights: Bool = false,
        usePageContent: Bool = false
    ) {
        self.init(variables: _variables, defaults: Defaults(
            minSearchTerm: minSearchTerm,
            position: position,
            searchHighlights: searchHighlights,
            usePageContent: usePageContent))
    }

    /// The minimum number of characters that the user types before searching in
     /// the page.
    public lazy var minSearchTerm: Int = {
        self._variables.getInt("min-search-term") ?? _defaults.minSearchTerm
    }()
    /// This property defines whether or not the feature is enabled, and the
     /// position of the search bar
     /// 
    public lazy var position: SearchBarPositionFeature = {
        self._variables.getVariables("position")?.map(SearchBarPositionFeature.create)._mergeWith(_defaults.position) ?? _defaults.position
    }()
    /// Whether or not search highlights are enabled
    public lazy var searchHighlights: Bool = {
        self._variables.getBool("search-highlights") ?? _defaults.searchHighlights
    }()
    /// Search in the open tab's text content when typing.
    public lazy var usePageContent: Bool = {
        self._variables.getBool("use-page-content") ?? _defaults.usePageContent
    }()
}

public extension AwesomeBar {
    func _mergeWith(_ defaults: AwesomeBar?) -> AwesomeBar {
        guard let defaults = defaults else {
            return self
        }
        return AwesomeBar(variables: self._variables, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> AwesomeBar {
        return AwesomeBar(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: AwesomeBar, _ defaults: AwesomeBar) -> AwesomeBar {
        return overrides._mergeWith(defaults)
    }
}

